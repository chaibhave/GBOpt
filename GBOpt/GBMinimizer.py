# Copyright 2025, Battelle Energy Alliance, LLC, ALL RIGHTS RESERVED

import math
import shutil
import sys
import uuid
from collections.abc import Callable
from time import time

import numpy as np

from GBOpt import GBMaker, GBManipulator


class Mutator:
    """
    Mutator class for performing random manipulations on the passed manipulator.
    :param choices: A list of strings corresponding to GBManipulator operations.
    :param manipulator: A GBManipulator instance for mapping the choices list to GBmethod calls.
    """
    # TODO: Add more manipulator options to this class as we make more manipulators faster.

    def __init__(self, choices: list, manipulator: GBManipulator):
        self.choices = {method: getattr(manipulator, method)
                        for method in choices if hasattr(manipulator, method)}
        self.choices_keys = list(self.choices.keys())

    def mutate(self, local_random: np.random.default_rng, GB: GBMaker, manipulator: GBManipulator):
        """Performs a random mutation from the choices.
        :param local_random: A numpy.random.default_rng object for generating the random choices.
        "param GB: GBMaker object to get GB parameters for the mutation.
        :param GBManipulator: GBManipulator object to perform the mutation on.
        :return: Atom positions after the mutation."""
        choice_key = local_random.choice(self.choices_keys)
        match choice_key:
            case "insert_atoms":
                new_system = manipulator.insert_atoms(
                    method="grid", num_to_insert=1)

            case "remove_atoms":
                new_system = manipulator.remove_atoms(num_to_remove=1)

            case "translate_right_grain":
                dz = (GB.z_dim / GB.repeat_factor[1]
                      ) * local_random.uniform(0, 1)
                dy = (GB.z_dim / GB.repeat_factor[0]
                      ) * local_random.uniform(0, 1)
                new_system = manipulator.translate_right_grain(dy=dy, dz=dz)
        return new_system


class MonteCarloMinimizer:
    """
    Minimizer class for finding the lowest energy configuration of a grain boundary.
    Runs a Monte-Carlo minimization approach on the provided GBMaker object, applying the provided manipulator options stochastically.
    :param GB: GBMaker object to perform minimization on.
    :param gb_energy_func: A function that returns the energy of test GB structure. Currently expects a function
    that can be called with the params (GBMaker,GBManipulator,atom_positions,unique_id) .
    :param choices: A list of strings corresponding to GBManipulator operations. Used in setting up the Mutator class.
    :param seed: The seed to initialize the numpy.random.default_rng with.
    """

    def __init__(self, GB: GBMaker, gb_energy_func: Callable, choices: list, seed=time()):
        self.GB = GB
        self.gb_energy_func = gb_energy_func
        self.manipulator = GBManipulator(self.GB)
        self.mutator = Mutator(choices, self.manipulator)
        self.accepted_idx = [0]  # Initial guess is accepted by definition
        self.__operation_list__ = ["START"]
        self.local_random = np.random.default_rng(seed)
        self.manipulator.rng = self.local_random
        self.GBE_vals = []

    def run_MC(self, E_accept: float = 1e-1, max_steps: int = 50, E_tol: float = 1e-4, max_rejections: int = 20, cooldown_rate: float = 1.0, unique_id: int = uuid.uuid4()) -> float:
        # TODO: Add options for changing from linear to logarithmic cooldown
        """
        Runs an MC loop on the grain boundary structure till the set convergence criteria are met.
        The convergence criteria parameters are optional.
        :param E_accept: Energy increase value that should have a 50% chance of being accepted during the MC iterations (default value is in J/m^2).
        :param max_steps: Sets the maximum number of iterations of MC that are run.
        :param E_tol: Grain boundary energy decrease cut-off for terminating MC iterations (default value is in J/m^2).
        :param max_rejections: Maximum number of consequtive rejections before the MC iterations are terminated.
        :param cooldown_rate: Factor ((0,1]) by which to reduce the 'temperature' of the MC simulation each iteration.
        :param unique_id: Unique unsigned integer to which to label all files generated by the MC run.
        :return: Minimized energy value.
        """

        assert cooldown_rate > 0.0 and cooldown_rate <= 1.0

        # Get initial energy
        init_gbe, _ = self.gb_energy_func(
            self.GB,
            self.manipulator,
            self.manipulator.parents[0].whole_system,
            "initial"+str(unique_id),
        )
        # Append grain boundary energy calculation to array
        self.GBE_vals.append(init_gbe)

        # Set the Monte-Carlo temperature such that there is a 50% probability of accepting an `E_accept` amount of increase to the GBE
        T = -1 * E_accept / math.log(0.5)
        rejection_count = 0

        # Set the minimum GBE
        min_gbe = min(self.GBE_vals)

        # Run the MC iterations
        for i in range(1, max_steps + 1):
            prev_gbe = self.GBE_vals[-1]

            # Generate a random mutation on the current GB atom structure
            new_system = self.mutator.mutate(
                self.local_random, self.GB, self.manipulator)

            # Evaluate the energy of this new structure and append it to the GBE values list
            new_gbe, dump_file_name = self.gb_energy_func(
                self.GB,
                self.manipulator,
                new_system,
                str(unique_id),
            )
            self.GBE_vals.append(new_gbe)

            # Accept this new structure if the energy decreases from the previous MC iteration OR probabilistically based on the energy increase
            accepted = new_gbe <= prev_gbe or self.local_random.uniform(
                0, 1) <= math.exp(-(new_gbe - prev_gbe) / T)

            if accepted:
                # Generate a new GB manipulator using the new structure from the dump file
                self.manipulator = GBManipulator(
                    dump_file_name,
                    unit_cell=self.GB.unit_cell,
                    gb_thickness=self.GB.gb_thickness,
                )
                self.manipulator.rng = self.local_random
                prev_gbe = new_gbe

                # Add the MC iteration index to the list of accepted values indices
                self.accepted_idx.append(i)
                # Set the consecutive rejection counter to zero
                rejection_count = 0

                # If new structure has the lowest energy observed so far, update the minimum GBE value and copy the dump file for this structure
                if new_gbe <= min_gbe:
                    shutil.copyfile(dump_file_name, "min" + dump_file_name)
                    del_E = abs(min_gbe - new_gbe)
                    # If the reduction in minimum energy was less than the tolerance threshold, we consider the MC solve converged
                    if del_E <= E_tol:
                        print("Meets energy tolerance criterion!")
                        break
                    min_gbe = new_gbe
            else:
                rejection_count += 1
                # If too many structures are rejected back-to-back, we prematurely stop the MC iterations since we are stuck
                if rejection_count > max_rejections:
                    print("Too many rejections!")
                    break
            # The temperature is cooled down to gradually reduce the probability of accepting worse solutions over time and let the MC minimization converge
            T *= cooldown_rate

        return min_gbe


class GeneticAlgorithmMinimizer:
    """
    Minimizer class for finding the lowest energy configuration of a grain boundary
    using a simple genetic algorithm (GA).
    Mirrors the interface of MonteCarloMinimizer while using GA operations to explore
    the configuration space.
    """

    def __init__(self, GB: GBMaker, gb_energy_func: Callable, choices: list, seed=time(), *, population_size: int = 20, generations: int = 50, keep_top_pct: int = 10, intermediate_pct: int = 60, gb_batch_energy_func: Callable | None = None):
        """
        :param GB: GBMaker object to perform minimization on.
        :param gb_energy_func: Function that returns the energy of a GB structure. It must be callable with
            (GBMaker, GBManipulator, atom_positions, unique_id).
        :param choices: List of strings corresponding to GBManipulator operations. Used to configure the Mutator.
        :param seed: Seed for numpy.random.default_rng. Keyword argument, optional, defaults to the current time.
        :param population_size: Number of candidates per generation. Keyword argument, optional, defaults to 20.
        :param generations: Number of generations to iterate. Keyword argument, optional, defaults to 50.
        :param keep_top_pct: Percentage of lowest-energy structures carried over unchanged. Keyword argument, optional,
            defaults to 10.
        :param intermediate_pct: Percentage of structures eligible for crossover/mutation selection. Keyword argument,
            optional, defaults to 60.
        :param gb_batch_energy_func: Optional batch-evaluation function for processing a population in one call. It
            should accept (GBMaker, manipulators, atom_positions_list, lineages, unique_ids) and return a list of
            dictionaries containing at least ``"energy"`` and ``"final_dump"`` keys. If not provided, fall back to
            calling ``gb_energy_func`` per candidate.
        """
        self.GB = GB
        self.gb_energy_func = gb_energy_func
        self.gb_batch_energy_func = gb_batch_energy_func
        self.manipulator = GBManipulator(self.GB)
        self.mutator = Mutator(choices, self.manipulator)
        self.local_random = np.random.default_rng(seed)
        self.manipulator.rng = self.local_random
        self.population_size = population_size
        self.generations = generations
        self.keep_top_pct = keep_top_pct
        self.intermediate_pct = intermediate_pct
        self.GBE_vals = []

    def _make_manipulator_from_file(self, filename: str) -> GBManipulator:
        manipulator = GBManipulator(
            filename,
            unit_cell=self.GB.unit_cell,
            gb_thickness=self.GB.gb_thickness,
        )
        manipulator.rng = self.local_random
        return manipulator

    def _select_indices_by_energy(self, energies: list) -> tuple[list[int], list[int]]:
        idx_sorted = sorted(range(len(energies)), key=lambda i: energies[i])

        n_top = max(0, (len(energies) * self.keep_top_pct) // 100)
        n_inter = max(0, (len(energies) * self.intermediate_pct) // 100)

        lowest_top = idx_sorted[:n_top]
        intermediate = idx_sorted[:n_inter]
        return lowest_top, intermediate

    def _evaluate_generation(self, population_manipulators: list[GBManipulator], population_structures: list[np.ndarray],
                             population_lineages: list[list[str]], gen: int, unique_id: int) -> tuple[list[float], list[str], list[GBManipulator]]:
        """Evaluate all candidates, optionally using a batch energy function."""
        if self.gb_batch_energy_func is not None:
            batch_results = self.gb_batch_energy_func(
                self.GB,
                population_manipulators,
                population_structures,
                population_lineages,
                [f"GA_{unique_id}_g{gen}_c{i}" for i in range(
                    len(population_structures))],
            )

            gen_energies = []
            gen_files = []
            evaluated_manipulators = []
            for result in batch_results:
                gen_energies.append(result["energy"])
                gen_files.append(result["final_dump"])
                evaluated_manipulators.append(
                    self._make_manipulator_from_file(result["final_dump"]))

            return gen_energies, gen_files, evaluated_manipulators

        gen_energies = []
        gen_files = []
        evaluated_manipulators = []

        for idx, (manipulator, atom_positions) in enumerate(zip(population_manipulators, population_structures)):
            gbe, dump_file_name = self.gb_energy_func(
                self.GB,
                manipulator,
                atom_positions,
                f"GA_{unique_id}_g{gen}_c{idx}",
            )

            gen_energies.append(gbe)
            gen_files.append(dump_file_name)
            new_manip = self._make_manipulator_from_file(dump_file_name)
            evaluated_manipulators.append(new_manip)

        return gen_energies, gen_files, evaluated_manipulators

    def _make_next_generation(self, files: list[str], intermediate_indices: list[int]) -> tuple[list[GBManipulator], list[np.ndarray], list[list[str]]]:
        candidates: list[np.ndarray] = []
        manipulators: list[GBManipulator] = []
        lineages: list[list[str]] = []

        N_slice = self.population_size // 2
        N_mutate = self.population_size - N_slice

        # Slice & merge
        for _ in range(N_slice):
            replace = len(intermediate_indices) < 2
            idx_1, idx_2 = self.local_random.choice(
                intermediate_indices, size=2, replace=replace)
            p1, p2 = files[idx_1], files[idx_2]
            new_manip = GBManipulator(
                p1,
                p2,
                unit_cell=self.GB.unit_cell,
                gb_thickness=self.GB.gb_thickness,
            )
            new_manip.rng = self.local_random
            new_struct = new_manip.slice_and_merge()

            candidates.append(new_struct)
            manipulators.append(new_manip)
            lineages.append([p1, p2])

        # Mutations
        if not intermediate_indices:
            intermediate_indices = list(range(len(files)))
        choices = self.local_random.choice(
            intermediate_indices, size=N_mutate, replace=True)
        for idx in choices:
            parent = files[idx]
            new_manip = GBManipulator(
                parent,
                unit_cell=self.GB.unit_cell,
                gb_thickness=self.GB.gb_thickness,
            )
            new_manip.rng = self.local_random
            new_struct = self.mutator.mutate(
                local_random=self.local_random,
                GB=self.GB,
                manipulator=new_manip,
            )

            candidates.append(new_struct)
            manipulators.append(new_manip)
            lineages.append([parent])

        return manipulators, candidates, lineages

    def run_GA(self, unique_id: int = uuid.uuid4()) -> tuple[float, str]:
        """
        Runs a genetic algorithm loop on the grain boundary structure.

        :param unique_id: Unique unsigned integer to which to label all files generated by the GA run.
        :return: Tuple containing the minimum energy value observed and the associated dump filename.
        """

        # Evaluate the initial structure
        init_gbe, init_dump = self.gb_energy_func(
            self.GB,
            self.manipulator,
            self.manipulator.parents[0].whole_system,
            "GA_initial"+str(unique_id),
        )
        self.GBE_vals.append([init_gbe])

        best_energy = init_gbe
        best_dump = init_dump

        base_parent = init_dump
        population_manipulators = []
        population_structures = []
        population_lineages = []

        for _ in range(self.population_size):
            candidate_manip = self._make_manipulator_from_file(base_parent)
            candidate_struct = self.mutator.mutate(
                local_random=self.local_random,
                GB=self.GB,
                manipulator=candidate_manip,
            )
            population_manipulators.append(candidate_manip)
            population_structures.append(candidate_struct)
            population_lineages.append([base_parent])

        # Main GA loop
        for gen in range(self.generations):
            gen_energies, gen_files, evaluated_manipulators = self._evaluate_generation(
                population_manipulators,
                population_structures,
                population_lineages,
                gen,
                unique_id,
            )

            for gbe, dump_file_name in zip(gen_energies, gen_files):
                if gbe < best_energy:
                    best_energy = gbe
                    best_dump = dump_file_name

            self.GBE_vals.append(gen_energies)

            # Selection
            lowest_idxs, inter_idxs = self._select_indices_by_energy(gen_energies)

            # Carry over lowest energies
            next_manipulators = []
            next_structures = []
            next_lineages = []
            for idx in lowest_idxs:
                manip = evaluated_manipulators[idx]
                next_manipulators.append(manip)
                next_structures.append(manip.parents[0].whole_system)
                next_lineages.append([gen_files[idx]])

            # Build the remainder of the next generation
            carryover_files = gen_files
            new_manips, new_structs, new_lineages = self._make_next_generation(
                carryover_files,
                inter_idxs,
            )
            next_manipulators.extend(new_manips)
            next_structures.extend(new_structs)
            next_lineages.extend(new_lineages)

            population_manipulators = next_manipulators[:self.population_size]
            population_structures = next_structures[:self.population_size]
            population_lineages = next_lineages[:self.population_size]

        return best_energy, best_dump
